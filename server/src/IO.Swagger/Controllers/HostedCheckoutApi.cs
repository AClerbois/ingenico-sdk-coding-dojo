/*
 * Ingenico Direct
 *
 *  # Introduction  The Ingenico Direct API has been designed as a REST API. It uses the HTTP protocol as its foundation. Each resource is accessible under a clearly named URL and the HTTP response codes are used to relay status. HTTP Verbs like GET and POST are used to interact with the resources. To support accessibility by clients directly, as opposed to your server, our servers support cross-origin resource sharing. We use JSON for all of our payloads, including error messages   All these characteristics mean that you will be able to use standard off the shelf software to interact with Ingenico ePayments. To make the integration even easier, Ingenico ePayments also has SDKs that wrap both the complete Server API as well as the complete Client API. 
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Collections.Generic;
using Microsoft.AspNetCore.Mvc;
using Swashbuckle.AspNetCore.Annotations;
using Swashbuckle.AspNetCore.SwaggerGen;
using Newtonsoft.Json;
using System.ComponentModel.DataAnnotations;
using IO.Swagger.Attributes;
using IO.Swagger.Security;
using Microsoft.AspNetCore.Authorization;
using IO.Swagger.Models;

namespace IO.Swagger.Controllers
{ 
    /// <summary>
    /// 
    /// </summary>
    [ApiController]
    public class HostedCheckoutApiController : ControllerBase
    { 
        /// <summary>
        /// Create hosted checkout
        /// </summary>
        /// <remarks>You can start a hostedCheckout flow by posting the relevant details to the endpoint. We will then return you all the details you need to redirect the consumer to us, retrieve the status and recognize the consumer when he/she returns to your website.   The hosted checkout allows the use of three distinct components:  * Presenting a (filtered) list of payment products that the consumer can choose from;  * Handling of the actual payment, potentially involving data capture, redirection and/or the displaying of payment instructions;  * Presenting a confirmation/failure page after the payment.    Step 1 and 3 from the above list are optional. When no or partial filtering is provided, the first page the consumer will see is a payment product selection page. However, the hosted checkout will start as if a payment product had been selected if that specific payment product is the only entry in the request&#39;s restriction filters.  By providing payment product ids and groups in the hostedCheckoutSpecificInput&#39;s paymentProductFilters object, you can reduce the list of available payment products by either excluding or restricting to certain products. Note that at least one viable payment product must be left after filtering and that exclusion is leading, meaning that restricting and excluding the same product will lead to exclusion.  By setting the tokensOnly boolean to true, as part of the paymentProductFilters object, the consumer may only complete the payment using one of the accounts on file provided in the tokens property of hostedCheckoutSpecificInput.  By setting the showResultPage boolean to false, as part of the hostedCheckoutSpecificInput, the system will skip the confirmation/failure page after the consumer has completed the payment. This setting is true by default and the results page will be presented to the user.  In case the payment product selection page needs to be skipped the hostedCheckout call needs to contain one of the following objects in which all payment products have been categorized. These will also be used if the consumer selects a related payment product.  * Card payments - cardPaymentMethodSpecificInput  * All credit and debit card products fall into this category if they allow for direct submission of card data without a redirect to a third party to capture the card details.  * Redirect payments - redirectPaymentMethodSpecificInput  * All payment products that involve a redirect to a 3rd party to complete the payment directly online, like PayPal.  A generic transaction can be submitted using the order and the fraudFields objects.</remarks>
        /// <param name="merchantId">The Merchant Id</param>
        /// <param name="createHostedCheckoutRequest"></param>
        /// <response code="200"></response>
        /// <response code="400">Bad request</response>
        [HttpPost]
        [Route("/v1/{merchantId}/hostedcheckouts")]
        [ValidateModelState]
        [SwaggerOperation("HostedCheckoutCreate")]
        [SwaggerResponse(statusCode: 200, type: typeof(CreateHostedCheckoutResponse), description: "")]
        [SwaggerResponse(statusCode: 400, type: typeof(CreateHostedCheckoutResponse), description: "Bad request")]
        public virtual IActionResult HostedCheckoutCreate([FromRoute][Required]string merchantId, [FromBody]CreateHostedCheckoutRequest createHostedCheckoutRequest)
        { 
            //TODO: Uncomment the next line to return response 200 or use other options such as return this.NotFound(), return this.BadRequest(..), ...
            // return StatusCode(200, default(CreateHostedCheckoutResponse));

            //TODO: Uncomment the next line to return response 400 or use other options such as return this.NotFound(), return this.BadRequest(..), ...
            // return StatusCode(400, default(CreateHostedCheckoutResponse));

            string exampleJson = null;
            exampleJson = "{\n  \"hostedCheckoutId\" : \"hostedCheckoutId\",\n  \"partialRedirectUrl\" : \"partialRedirectUrl\",\n  \"returnmac\" : \"returnmac\",\n  \"merchantReference\" : \"merchantReference\",\n  \"invalidTokens\" : [ \"invalidTokens\", \"invalidTokens\" ]\n}";
            
            var example = exampleJson != null
            ? JsonConvert.DeserializeObject<CreateHostedCheckoutResponse>(exampleJson)
            : default(CreateHostedCheckoutResponse);
            //TODO: Change the data returned
            return new ObjectResult(example);
        }

        /// <summary>
        /// Get hosted checkout status
        /// </summary>
        /// <remarks>You can retrieve the current status of the hosted checkout by doing a get on the hostedCheckoutId. When a payment has been created during the hosted checkout session the details are returned in this object.  Sessions have a maximum life span of 2 hours. This means that you can only retrieve this information while the session has not timed-out.  The status of the hostedCheckout and the payment will change when the consumer is still busy completing the hosted checkout session.</remarks>
        /// <param name="merchantId">The Merchant Id</param>
        /// <param name="hostedcheckoutId">The HostedCheckout Id</param>
        /// <response code="200">The request was processed correctly and a valid response is returned. In case a payment was created during the hosted checkout the details are returned in the createdPaymentOutput object.</response>
        /// <response code="404">Bad request</response>
        [HttpGet]
        [Route("/v1/{merchantId}/hostedcheckouts/{hostedcheckoutId}")]
        [ValidateModelState]
        [SwaggerOperation("HostedCheckoutGetHostedcheckoutStatus")]
        [SwaggerResponse(statusCode: 200, type: typeof(GetHostedCheckoutResponse), description: "The request was processed correctly and a valid response is returned. In case a payment was created during the hosted checkout the details are returned in the createdPaymentOutput object.")]
        [SwaggerResponse(statusCode: 404, type: typeof(GetHostedCheckoutResponse), description: "Bad request")]
        public virtual IActionResult HostedCheckoutGetHostedcheckoutStatus([FromRoute][Required]string merchantId, [FromRoute][Required]string hostedcheckoutId)
        { 
            //TODO: Uncomment the next line to return response 200 or use other options such as return this.NotFound(), return this.BadRequest(..), ...
            // return StatusCode(200, default(GetHostedCheckoutResponse));

            //TODO: Uncomment the next line to return response 404 or use other options such as return this.NotFound(), return this.BadRequest(..), ...
            // return StatusCode(404, default(GetHostedCheckoutResponse));

            string exampleJson = null;
            exampleJson = "{\n  \"createdPaymentOutput\" : {\n    \"paymentStatusCategory\" : \"paymentStatusCategory\",\n    \"paymentCreationReferences\" : {\n      \"externalReference\" : \"externalReference\",\n      \"additionalReference\" : \"additionalReference\"\n    },\n    \"tokenizationSucceeded\" : true,\n    \"payment\" : \"\",\n    \"tokens\" : \"tokens\",\n    \"displayedData\" : {\n      \"showData\" : [ {\n        \"value\" : \"value\",\n        \"key\" : \"key\"\n      }, {\n        \"value\" : \"value\",\n        \"key\" : \"key\"\n      } ],\n      \"displayedDataType\" : \"displayedDataType\",\n      \"renderingData\" : \"renderingData\"\n    }\n  },\n  \"status\" : \"status\"\n}";
            
            var example = exampleJson != null
            ? JsonConvert.DeserializeObject<GetHostedCheckoutResponse>(exampleJson)
            : default(GetHostedCheckoutResponse);
            //TODO: Change the data returned
            return new ObjectResult(example);
        }
    }
}
