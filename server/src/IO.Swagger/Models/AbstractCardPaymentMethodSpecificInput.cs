/*
 * Ingenico Direct
 *
 *  # Introduction  The Ingenico Direct API has been designed as a REST API. It uses the HTTP protocol as its foundation. Each resource is accessible under a clearly named URL and the HTTP response codes are used to relay status. HTTP Verbs like GET and POST are used to interact with the resources. To support accessibility by clients directly, as opposed to your server, our servers support cross-origin resource sharing. We use JSON for all of our payloads, including error messages   All these characteristics mean that you will be able to use standard off the shelf software to interact with Ingenico ePayments. To make the integration even easier, Ingenico ePayments also has SDKs that wrap both the complete Server API as well as the complete Client API. 
 *
 * OpenAPI spec version: 1.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */

using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel.DataAnnotations;
using System.Runtime.Serialization;
using Newtonsoft.Json;

namespace IO.Swagger.Models
{ 
    /// <summary>
    /// 
    /// </summary>
    [DataContract]
    public partial class AbstractCardPaymentMethodSpecificInput : AbstractPaymentMethodSpecificInput, IEquatable<AbstractCardPaymentMethodSpecificInput>
    { 
        /// <summary>
        /// Determines the type of the authorization that will be used. Allowed values:   * FINAL_AUTHORIZATION - The payment creation results in an authorization that is ready for capture. Final authorizations can&#39;t be reversed and need to be captured for the full amount within 7 days.   * PRE_AUTHORIZATION - The payment creation results in a pre-authorization that is ready for capture. Pre-authortizations can be reversed and can be captured within 30 days. The capture amount can be lower than the authorized amount.   * SALE - The payment creation results in an authorization that is already captured at the moment of approval.    Only used with some acquirers, ingnored for acquirers that don&#39;t support this. In case the acquirer doesn&#39;t allow this to be specified the authorizationMode is &#39;unspecified&#39;, which behaves similar to a final authorization.
        /// </summary>
        /// <value>Determines the type of the authorization that will be used. Allowed values:   * FINAL_AUTHORIZATION - The payment creation results in an authorization that is ready for capture. Final authorizations can&#39;t be reversed and need to be captured for the full amount within 7 days.   * PRE_AUTHORIZATION - The payment creation results in a pre-authorization that is ready for capture. Pre-authortizations can be reversed and can be captured within 30 days. The capture amount can be lower than the authorized amount.   * SALE - The payment creation results in an authorization that is already captured at the moment of approval.    Only used with some acquirers, ingnored for acquirers that don&#39;t support this. In case the acquirer doesn&#39;t allow this to be specified the authorizationMode is &#39;unspecified&#39;, which behaves similar to a final authorization.</value>
        [DataMember(Name="authorizationMode")]
        public string AuthorizationMode { get; set; }

        /// <summary>
        /// Reference of the customer for the payment (purchase order #, etc.). Only used with some acquirers.
        /// </summary>
        /// <value>Reference of the customer for the payment (purchase order #, etc.). Only used with some acquirers.</value>
        [DataMember(Name="customerReference")]
        public string CustomerReference { get; set; }

        /// <summary>
        /// Gets or Sets RecurringPaymentSequenceIndicator
        /// </summary>
        [DataMember(Name="recurringPaymentSequenceIndicator")]
        public string RecurringPaymentSequenceIndicator { get; set; }

        /// <summary>
        /// true &#x3D; the payment requires approval before the funds will be captured using the Approve payment or Capture payment API   * false &#x3D; the payment does not require approval, and the funds will be captured automatically
        /// </summary>
        /// <value>true &#x3D; the payment requires approval before the funds will be captured using the Approve payment or Capture payment API   * false &#x3D; the payment does not require approval, and the funds will be captured automatically</value>
        [DataMember(Name="requiresApproval")]
        public bool? RequiresApproval { get; set; }

        /// <summary>
        /// Gets or Sets SkipAuthentication
        /// </summary>
        [DataMember(Name="skipAuthentication")]
        public bool? SkipAuthentication { get; set; }

        /// <summary>
        ///    * true &#x3D; Fraud scoring will be skipped for this transaction   * false &#x3D; Fraud scoring will not be skipped for this transaction    Note: This is only possible if your account in our system is setup for Fraud scoring and if your configuration in our system allows you to override it per transaction.
        /// </summary>
        /// <value>   * true &#x3D; Fraud scoring will be skipped for this transaction   * false &#x3D; Fraud scoring will not be skipped for this transaction    Note: This is only possible if your account in our system is setup for Fraud scoring and if your configuration in our system allows you to override it per transaction.</value>
        [DataMember(Name="skipFraudService")]
        public bool? SkipFraudService { get; set; }

        /// <summary>
        /// ID of the token. This property is populated when the payment was done with a token or when the payment was tokenized.
        /// </summary>
        /// <value>ID of the token. This property is populated when the payment was done with a token or when the payment was tokenized.</value>
        [DataMember(Name="token")]
        public string Token { get; set; }

        /// <summary>
        /// Indicates if this transaction should be tokenized   * true - Tokenize the transaction.   * false - Do not tokenize the transaction, unless it would be tokenized by other means such as auto-tokenization of recurring payments.
        /// </summary>
        /// <value>Indicates if this transaction should be tokenized   * true - Tokenize the transaction.   * false - Do not tokenize the transaction, unless it would be tokenized by other means such as auto-tokenization of recurring payments.</value>
        [DataMember(Name="tokenize")]
        public bool? Tokenize { get; set; }

        /// <summary>
        /// Indicates the channel via which the payment is created. Allowed values:   * ECOMMERCE - The transaction is a regular E-Commerce transaction.   * MAIL - The transaction is a Mail Order.   * MOTO - The transaction is a Mail Order/Telephone Order.   * TELEPHONE - The transaction is a Telephone Order.   Defaults to ECOMMERCE.
        /// </summary>
        /// <value>Indicates the channel via which the payment is created. Allowed values:   * ECOMMERCE - The transaction is a regular E-Commerce transaction.   * MAIL - The transaction is a Mail Order.   * MOTO - The transaction is a Mail Order/Telephone Order.   * TELEPHONE - The transaction is a Telephone Order.   Defaults to ECOMMERCE.</value>
        [DataMember(Name="transactionChannel")]
        public string TransactionChannel { get; set; }

        /// <summary>
        ///    * first &#x3D; This transaction is the first of a series of unscheduled recurring transactions   * subsequent &#x3D; This transaction is a subsequent transaction in a series of unscheduled recurring transactions    Note: this property is not allowed if isRecurring is true.
        /// </summary>
        /// <value>   * first &#x3D; This transaction is the first of a series of unscheduled recurring transactions   * subsequent &#x3D; This transaction is a subsequent transaction in a series of unscheduled recurring transactions    Note: this property is not allowed if isRecurring is true.</value>
        [DataMember(Name="unscheduledCardOnFileIndicator")]
        public string UnscheduledCardOnFileIndicator { get; set; }

        /// <summary>
        /// Indicates which party initiated the unscheduled recurring transaction. Allowed values:   * merchantInitiated - Merchant Initiated Transaction.   * cardholderInitiated - Cardholder Initiated Transaction.    Note: this property is not allowed if isRecurring is true.     Depends on:   Required when unscheduledCardOnFileIndicator is &#39;subsequent&#39;. Otherwise it must not be &#39;merchantInitiated&#39;.
        /// </summary>
        /// <value>Indicates which party initiated the unscheduled recurring transaction. Allowed values:   * merchantInitiated - Merchant Initiated Transaction.   * cardholderInitiated - Cardholder Initiated Transaction.    Note: this property is not allowed if isRecurring is true.     Depends on:   Required when unscheduledCardOnFileIndicator is &#39;subsequent&#39;. Otherwise it must not be &#39;merchantInitiated&#39;.</value>
        [DataMember(Name="unscheduledCardOnFileRequestor")]
        public string UnscheduledCardOnFileRequestor { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class AbstractCardPaymentMethodSpecificInput {\n");
            sb.Append("  AuthorizationMode: ").Append(AuthorizationMode).Append("\n");
            sb.Append("  CustomerReference: ").Append(CustomerReference).Append("\n");
            sb.Append("  RecurringPaymentSequenceIndicator: ").Append(RecurringPaymentSequenceIndicator).Append("\n");
            sb.Append("  RequiresApproval: ").Append(RequiresApproval).Append("\n");
            sb.Append("  SkipAuthentication: ").Append(SkipAuthentication).Append("\n");
            sb.Append("  SkipFraudService: ").Append(SkipFraudService).Append("\n");
            sb.Append("  Token: ").Append(Token).Append("\n");
            sb.Append("  Tokenize: ").Append(Tokenize).Append("\n");
            sb.Append("  TransactionChannel: ").Append(TransactionChannel).Append("\n");
            sb.Append("  UnscheduledCardOnFileIndicator: ").Append(UnscheduledCardOnFileIndicator).Append("\n");
            sb.Append("  UnscheduledCardOnFileRequestor: ").Append(UnscheduledCardOnFileRequestor).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public  new string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="obj">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj.GetType() == GetType() && Equals((AbstractCardPaymentMethodSpecificInput)obj);
        }

        /// <summary>
        /// Returns true if AbstractCardPaymentMethodSpecificInput instances are equal
        /// </summary>
        /// <param name="other">Instance of AbstractCardPaymentMethodSpecificInput to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(AbstractCardPaymentMethodSpecificInput other)
        {
            if (ReferenceEquals(null, other)) return false;
            if (ReferenceEquals(this, other)) return true;

            return 
                (
                    AuthorizationMode == other.AuthorizationMode ||
                    AuthorizationMode != null &&
                    AuthorizationMode.Equals(other.AuthorizationMode)
                ) && 
                (
                    CustomerReference == other.CustomerReference ||
                    CustomerReference != null &&
                    CustomerReference.Equals(other.CustomerReference)
                ) && 
                (
                    RecurringPaymentSequenceIndicator == other.RecurringPaymentSequenceIndicator ||
                    RecurringPaymentSequenceIndicator != null &&
                    RecurringPaymentSequenceIndicator.Equals(other.RecurringPaymentSequenceIndicator)
                ) && 
                (
                    RequiresApproval == other.RequiresApproval ||
                    RequiresApproval != null &&
                    RequiresApproval.Equals(other.RequiresApproval)
                ) && 
                (
                    SkipAuthentication == other.SkipAuthentication ||
                    SkipAuthentication != null &&
                    SkipAuthentication.Equals(other.SkipAuthentication)
                ) && 
                (
                    SkipFraudService == other.SkipFraudService ||
                    SkipFraudService != null &&
                    SkipFraudService.Equals(other.SkipFraudService)
                ) && 
                (
                    Token == other.Token ||
                    Token != null &&
                    Token.Equals(other.Token)
                ) && 
                (
                    Tokenize == other.Tokenize ||
                    Tokenize != null &&
                    Tokenize.Equals(other.Tokenize)
                ) && 
                (
                    TransactionChannel == other.TransactionChannel ||
                    TransactionChannel != null &&
                    TransactionChannel.Equals(other.TransactionChannel)
                ) && 
                (
                    UnscheduledCardOnFileIndicator == other.UnscheduledCardOnFileIndicator ||
                    UnscheduledCardOnFileIndicator != null &&
                    UnscheduledCardOnFileIndicator.Equals(other.UnscheduledCardOnFileIndicator)
                ) && 
                (
                    UnscheduledCardOnFileRequestor == other.UnscheduledCardOnFileRequestor ||
                    UnscheduledCardOnFileRequestor != null &&
                    UnscheduledCardOnFileRequestor.Equals(other.UnscheduledCardOnFileRequestor)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                var hashCode = 41;
                // Suitable nullity checks etc, of course :)
                    if (AuthorizationMode != null)
                    hashCode = hashCode * 59 + AuthorizationMode.GetHashCode();
                    if (CustomerReference != null)
                    hashCode = hashCode * 59 + CustomerReference.GetHashCode();
                    if (RecurringPaymentSequenceIndicator != null)
                    hashCode = hashCode * 59 + RecurringPaymentSequenceIndicator.GetHashCode();
                    if (RequiresApproval != null)
                    hashCode = hashCode * 59 + RequiresApproval.GetHashCode();
                    if (SkipAuthentication != null)
                    hashCode = hashCode * 59 + SkipAuthentication.GetHashCode();
                    if (SkipFraudService != null)
                    hashCode = hashCode * 59 + SkipFraudService.GetHashCode();
                    if (Token != null)
                    hashCode = hashCode * 59 + Token.GetHashCode();
                    if (Tokenize != null)
                    hashCode = hashCode * 59 + Tokenize.GetHashCode();
                    if (TransactionChannel != null)
                    hashCode = hashCode * 59 + TransactionChannel.GetHashCode();
                    if (UnscheduledCardOnFileIndicator != null)
                    hashCode = hashCode * 59 + UnscheduledCardOnFileIndicator.GetHashCode();
                    if (UnscheduledCardOnFileRequestor != null)
                    hashCode = hashCode * 59 + UnscheduledCardOnFileRequestor.GetHashCode();
                return hashCode;
            }
        }

        #region Operators
        #pragma warning disable 1591

        public static bool operator ==(AbstractCardPaymentMethodSpecificInput left, AbstractCardPaymentMethodSpecificInput right)
        {
            return Equals(left, right);
        }

        public static bool operator !=(AbstractCardPaymentMethodSpecificInput left, AbstractCardPaymentMethodSpecificInput right)
        {
            return !Equals(left, right);
        }

        #pragma warning restore 1591
        #endregion Operators
    }
}
